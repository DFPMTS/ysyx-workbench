import chisel3._
import chisel3.util._
import chisel3.util.experimental._
import chisel3.util.experimental.decode.TruthTable
import chisel3.util.experimental.decode.decoder
import scala.language.implicitConversions

class DecodeSignals extends Bundle {
  val invalid  = Bool()
  val regWe    = Bool()
  val src1Type = UInt(2.W)
  val src2Type = UInt(2.W)
  val aluFunc  = UInt(4.W)
  val fuType   = UInt(2.W)
  val instType = UInt(3.W)
  val fuOp     = UInt(2.W)
}

class Decode extends Module with HasDecodeConstants {
  val io = IO(new Bundle {
    val inst    = Input(UInt(32.W))
    val signals = Output(new DecodeSignals)
  })
  implicit def uintToBitPat(x: UInt): BitPat = BitPat(x)
  val defaultCtrl: List[BitPat] = List(Y, N, ZERO, ZERO, ALU_ADD, ALU, IMM_X, OP_X)
  val lut: List[(BitPat, List[BitPat])] = List(
    BitPat("b??????? ????? ????? ??? ????? 01101 11") -> List(N, Y, ZERO, IMM, ALU_ADD, ALU, IMM_U, OP_X),
    BitPat("b??????? ????? ????? ??? ????? 00101 11") -> List(N, Y, PC, IMM, ALU_ADD, ALU, IMM_U, OP_X),
    BitPat("b??????? ????? ????? ??? ????? 11011 11") -> List(N, Y, PC, IMM, ALU_ADD, BRU, IMM_J, JUMP),
    BitPat("b??????? ????? ????? ??? ????? 11001 11") -> List(N, Y, REG, IMM, ALU_ADD, BRU, IMM_I, JUMP),
    BitPat("b??????? ????? ????? 000 ????? 11000 11") -> List(N, N, REG, REG, ALU_EQ, BRU, IMM_B, BRANCH),
    BitPat("b??????? ????? ????? 001 ????? 11000 11") -> List(N, N, REG, REG, ALU_NE, BRU, IMM_B, BRANCH),
    BitPat("b??????? ????? ????? 100 ????? 11000 11") -> List(N, N, REG, REG, ALU_LT, BRU, IMM_B, BRANCH),
    BitPat("b??????? ????? ????? 101 ????? 11000 11") -> List(N, N, REG, REG, ALU_GE, BRU, IMM_B, BRANCH),
    BitPat("b??????? ????? ????? 110 ????? 11000 11") -> List(N, N, REG, REG, ALU_LTU, BRU, IMM_B, BRANCH),
    BitPat("b??????? ????? ????? 111 ????? 11000 11") -> List(N, N, REG, REG, ALU_GEU, BRU, IMM_B, BRANCH),
    BitPat("b??????? ????? ????? 000 ????? 00000 11") -> List(N, Y, REG, IMM, ALU_ADD, MEM, IMM_I, LB),
    BitPat("b??????? ????? ????? 001 ????? 00000 11") -> List(N, Y, REG, IMM, ALU_ADD, MEM, IMM_I, LH),
    BitPat("b??????? ????? ????? 010 ????? 00000 11") -> List(N, Y, REG, IMM, ALU_ADD, MEM, IMM_I, LW),
    BitPat("b??????? ????? ????? 100 ????? 00000 11") -> List(N, Y, REG, IMM, ALU_ADD, MEM, IMM_I, LBU),
    BitPat("b??????? ????? ????? 101 ????? 00000 11") -> List(N, Y, REG, IMM, ALU_ADD, MEM, IMM_I, LHU),
    BitPat("b??????? ????? ????? 000 ????? 01000 11") -> List(N, N, REG, IMM, ALU_ADD, MEM, IMM_S, SB),
    BitPat("b??????? ????? ????? 001 ????? 01000 11") -> List(N, N, REG, IMM, ALU_ADD, MEM, IMM_S, SH),
    BitPat("b??????? ????? ????? 010 ????? 01000 11") -> List(N, N, REG, IMM, ALU_ADD, MEM, IMM_S, SW),
    BitPat("b??????? ????? ????? 000 ????? 00100 11") -> List(N, Y, REG, IMM, ALU_ADD, ALU, IMM_I, OP_X),
    BitPat("b??????? ????? ????? 010 ????? 00100 11") -> List(N, Y, REG, IMM, ALU_LT, ALU, IMM_I, OP_X),
    BitPat("b??????? ????? ????? 011 ????? 00100 11") -> List(N, Y, REG, IMM, ALU_LTU, ALU, IMM_I, OP_X),
    BitPat("b??????? ????? ????? 100 ????? 00100 11") -> List(N, Y, REG, IMM, ALU_XOR, ALU, IMM_I, OP_X),
    BitPat("b??????? ????? ????? 110 ????? 00100 11") -> List(N, Y, REG, IMM, ALU_OR, ALU, IMM_I, OP_X),
    BitPat("b??????? ????? ????? 111 ????? 00100 11") -> List(N, Y, REG, IMM, ALU_AND, ALU, IMM_I, OP_X),
    BitPat("b0000000 ????? ????? 001 ????? 00100 11") -> List(N, Y, REG, IMM, ALU_LEFT, ALU, IMM_I, OP_X),
    BitPat("b0000000 ????? ????? 101 ????? 00100 11") -> List(N, Y, REG, IMM, ALU_RIGHT, ALU, IMM_I, OP_X),
    BitPat("b0100000 ????? ????? 101 ????? 00100 11") -> List(N, Y, REG, IMM, ALU_ARITH, ALU, IMM_I, OP_X),
    BitPat("b0000000 ????? ????? 000 ????? 01100 11") -> List(N, Y, REG, REG, ALU_ADD, ALU, IMM_R, OP_X),
    BitPat("b0100000 ????? ????? 000 ????? 01100 11") -> List(N, Y, REG, REG, ALU_SUB, ALU, IMM_R, OP_X),
    BitPat("b0000000 ????? ????? 001 ????? 01100 11") -> List(N, Y, REG, REG, ALU_LEFT, ALU, IMM_R, OP_X),
    BitPat("b0000000 ????? ????? 010 ????? 01100 11") -> List(N, Y, REG, REG, ALU_LT, ALU, IMM_R, OP_X),
    BitPat("b0000000 ????? ????? 011 ????? 01100 11") -> List(N, Y, REG, REG, ALU_LTU, ALU, IMM_R, OP_X),
    BitPat("b0000000 ????? ????? 100 ????? 01100 11") -> List(N, Y, REG, REG, ALU_XOR, ALU, IMM_R, OP_X),
    BitPat("b0000000 ????? ????? 101 ????? 01100 11") -> List(N, Y, REG, REG, ALU_RIGHT, ALU, IMM_R, OP_X),
    BitPat("b0100000 ????? ????? 101 ????? 01100 11") -> List(N, Y, REG, REG, ALU_ARITH, ALU, IMM_R, OP_X),
    BitPat("b0000000 ????? ????? 110 ????? 01100 11") -> List(N, Y, REG, REG, ALU_OR, ALU, IMM_R, OP_X),
    BitPat("b0000000 ????? ????? 111 ????? 01100 11") -> List(N, Y, REG, REG, ALU_AND, ALU, IMM_R, OP_X),
    BitPat("b0000000 00000 00000 000 00000 11100 11") -> List(N, N, ZERO, ZERO, ALU_X, CSR, IMM_X, ECALL),
    BitPat("b0000000 00001 00000 000 00000 11100 11") -> List(N, N, ZERO, ZERO, ALU_X, CSR, IMM_X, EBREAK),
    BitPat("b??????? ????? ????? 001 ????? 11100 11") -> List(N, Y, REG, ZERO, ALU_ADD, CSR, IMM_I, CSRW),
    BitPat("b??????? ????? ????? 010 ????? 11100 11") -> List(N, Y, REG, ZERO, ALU_ADD, CSR, IMM_I, CSRS),
    BitPat("b0011000 00010 00000 000 00000 11100 11") -> List(N, N, ZERO, ZERO, ALU_X, CSR, IMM_X, MRET)
  )
  def listToBitPat(l: List[BitPat]) = {
    l.reduceLeft(_ ## _)
  }

  def transformLUT(lut: List[(BitPat, List[BitPat])]): List[(BitPat, BitPat)] = {
    lut.map {
      case (key, value) =>
        (key, listToBitPat(value))
    }
  }

  val table = TruthTable(transformLUT(lut), listToBitPat(defaultCtrl))
  io.signals := decoder(io.inst, table).asTypeOf(new DecodeSignals)
}
